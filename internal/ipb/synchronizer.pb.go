// Code generated by protoc-gen-go. DO NOT EDIT.
// source: internal/api/synchronizer.proto

package ipb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
	pb "ns-open-match/pkg/pb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SynchronizeRequest struct {
	// A match returned by an mmf.
	Proposal             *pb.Match `protobuf:"bytes,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SynchronizeRequest) Reset()         { *m = SynchronizeRequest{} }
func (m *SynchronizeRequest) String() string { return proto.CompactTextString(m) }
func (*SynchronizeRequest) ProtoMessage()    {}
func (*SynchronizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_35ff6b85fea1c4b7, []int{0}
}

func (m *SynchronizeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SynchronizeRequest.Unmarshal(m, b)
}
func (m *SynchronizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SynchronizeRequest.Marshal(b, m, deterministic)
}
func (m *SynchronizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SynchronizeRequest.Merge(m, src)
}
func (m *SynchronizeRequest) XXX_Size() int {
	return xxx_messageInfo_SynchronizeRequest.Size(m)
}
func (m *SynchronizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SynchronizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SynchronizeRequest proto.InternalMessageInfo

func (m *SynchronizeRequest) GetProposal() *pb.Match {
	if m != nil {
		return m.Proposal
	}
	return nil
}

type SynchronizeResponse struct {
	// Instructs the backend call that it can start running the mmfs.
	StartMmfs bool `protobuf:"varint,1,opt,name=start_mmfs,json=startMmfs,proto3" json:"start_mmfs,omitempty"`
	// Instructs the backend call that it should cancel any RPC calls to the mmfs,
	// not send any more matches, and close the send stream.
	CancelMmfs bool `protobuf:"varint,2,opt,name=cancel_mmfs,json=cancelMmfs,proto3" json:"cancel_mmfs,omitempty"`
	// A match ID returned by the evaluator and should be returned to the FetchMatches
	// caller.
	MatchId              string   `protobuf:"bytes,4,opt,name=match_id,json=matchId,proto3" json:"match_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SynchronizeResponse) Reset()         { *m = SynchronizeResponse{} }
func (m *SynchronizeResponse) String() string { return proto.CompactTextString(m) }
func (*SynchronizeResponse) ProtoMessage()    {}
func (*SynchronizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_35ff6b85fea1c4b7, []int{1}
}

func (m *SynchronizeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SynchronizeResponse.Unmarshal(m, b)
}
func (m *SynchronizeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SynchronizeResponse.Marshal(b, m, deterministic)
}
func (m *SynchronizeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SynchronizeResponse.Merge(m, src)
}
func (m *SynchronizeResponse) XXX_Size() int {
	return xxx_messageInfo_SynchronizeResponse.Size(m)
}
func (m *SynchronizeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SynchronizeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SynchronizeResponse proto.InternalMessageInfo

func (m *SynchronizeResponse) GetStartMmfs() bool {
	if m != nil {
		return m.StartMmfs
	}
	return false
}

func (m *SynchronizeResponse) GetCancelMmfs() bool {
	if m != nil {
		return m.CancelMmfs
	}
	return false
}

func (m *SynchronizeResponse) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func init() {
	proto.RegisterType((*SynchronizeRequest)(nil), "openmatch.internal.SynchronizeRequest")
	proto.RegisterType((*SynchronizeResponse)(nil), "openmatch.internal.SynchronizeResponse")
}

func init() { proto.RegisterFile("internal/api/synchronizer.proto", fileDescriptor_35ff6b85fea1c4b7) }

var fileDescriptor_35ff6b85fea1c4b7 = []byte{
	// 260 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x91, 0x3f, 0x4f, 0xc3, 0x30,
	0x10, 0xc5, 0x65, 0x88, 0x20, 0xbd, 0x30, 0x54, 0x66, 0x29, 0x11, 0xa8, 0x55, 0x07, 0xc8, 0x40,
	0x1d, 0x54, 0xbe, 0x41, 0x37, 0x90, 0xba, 0x84, 0x8d, 0xa5, 0x72, 0xd2, 0x2b, 0xb5, 0x14, 0xff,
	0xc1, 0x67, 0x90, 0xe0, 0xd3, 0xa3, 0x38, 0xa2, 0x2d, 0xea, 0xc0, 0x62, 0xe9, 0xee, 0x7e, 0xef,
	0x9d, 0xee, 0x19, 0xc6, 0xca, 0x04, 0xf4, 0x46, 0xb6, 0xa5, 0x74, 0xaa, 0xa4, 0x2f, 0xd3, 0x6c,
	0xbd, 0x35, 0xea, 0x1b, 0xbd, 0x70, 0xde, 0x06, 0xcb, 0xb9, 0x75, 0x68, 0xb4, 0x0c, 0xcd, 0x56,
	0xfc, 0xa2, 0x39, 0xef, 0x58, 0x8d, 0x44, 0xf2, 0x0d, 0xa9, 0xe7, 0xa6, 0x0b, 0xe0, 0x2f, 0x7b,
	0x75, 0x85, 0xef, 0x1f, 0x48, 0x81, 0xdf, 0x43, 0xea, 0xbc, 0x75, 0x96, 0x64, 0x3b, 0x62, 0x13,
	0x56, 0x64, 0xf3, 0xa1, 0xd8, 0x1b, 0x2e, 0xbb, 0xb7, 0xda, 0x11, 0xd3, 0x4f, 0xb8, 0xfc, 0xe3,
	0x41, 0xce, 0x1a, 0x42, 0x7e, 0x03, 0x40, 0x41, 0xfa, 0xb0, 0xd2, 0x7a, 0x43, 0xd1, 0x26, 0xad,
	0x06, 0xb1, 0xb3, 0xd4, 0x1b, 0xe2, 0x63, 0xc8, 0x1a, 0x69, 0x1a, 0x6c, 0xfb, 0xf9, 0x49, 0x9c,
	0x43, 0xdf, 0x8a, 0xc0, 0x15, 0xa4, 0x71, 0xdf, 0x4a, 0xad, 0x47, 0xc9, 0x84, 0x15, 0x83, 0xea,
	0x3c, 0xd6, 0x4f, 0xeb, 0xe7, 0x24, 0x3d, 0x1d, 0x26, 0x73, 0x0f, 0x17, 0x07, 0x7b, 0x3d, 0xaf,
	0x21, 0x3b, 0xa8, 0xf9, 0xad, 0x38, 0xce, 0x40, 0x1c, 0x1f, 0x9b, 0xdf, 0xfd, 0xcb, 0xf5, 0x07,
	0x15, 0xec, 0x81, 0x2d, 0xae, 0x5f, 0x73, 0x43, 0xb3, 0x4e, 0x30, 0x8b, 0x8a, 0x72, 0xf7, 0x11,
	0xca, 0xd5, 0xf5, 0x59, 0x0c, 0xf5, 0xf1, 0x27, 0x00, 0x00, 0xff, 0xff, 0xfa, 0xd7, 0x7b, 0x7b,
	0x9f, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SynchronizerClient is the client API for Synchronizer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SynchronizerClient interface {
	// Synchronize signals the caller when it is safe to run mmfs, collects the
	// mmfs' proposals, and returns the evaluated matches.
	Synchronize(ctx context.Context, opts ...grpc.CallOption) (Synchronizer_SynchronizeClient, error)
}

type synchronizerClient struct {
	cc *grpc.ClientConn
}

func NewSynchronizerClient(cc *grpc.ClientConn) SynchronizerClient {
	return &synchronizerClient{cc}
}

func (c *synchronizerClient) Synchronize(ctx context.Context, opts ...grpc.CallOption) (Synchronizer_SynchronizeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Synchronizer_serviceDesc.Streams[0], "/openmatch.internal.Synchronizer/Synchronize", opts...)
	if err != nil {
		return nil, err
	}
	x := &synchronizerSynchronizeClient{stream}
	return x, nil
}

type Synchronizer_SynchronizeClient interface {
	Send(*SynchronizeRequest) error
	Recv() (*SynchronizeResponse, error)
	grpc.ClientStream
}

type synchronizerSynchronizeClient struct {
	grpc.ClientStream
}

func (x *synchronizerSynchronizeClient) Send(m *SynchronizeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *synchronizerSynchronizeClient) Recv() (*SynchronizeResponse, error) {
	m := new(SynchronizeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SynchronizerServer is the server API for Synchronizer service.
type SynchronizerServer interface {
	// Synchronize signals the caller when it is safe to run mmfs, collects the
	// mmfs' proposals, and returns the evaluated matches.
	Synchronize(Synchronizer_SynchronizeServer) error
}

// UnimplementedSynchronizerServer can be embedded to have forward compatible implementations.
type UnimplementedSynchronizerServer struct {
}

func (*UnimplementedSynchronizerServer) Synchronize(srv Synchronizer_SynchronizeServer) error {
	return status.Errorf(codes.Unimplemented, "method Synchronize not implemented")
}

func RegisterSynchronizerServer(s *grpc.Server, srv SynchronizerServer) {
	s.RegisterService(&_Synchronizer_serviceDesc, srv)
}

func _Synchronizer_Synchronize_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SynchronizerServer).Synchronize(&synchronizerSynchronizeServer{stream})
}

type Synchronizer_SynchronizeServer interface {
	Send(*SynchronizeResponse) error
	Recv() (*SynchronizeRequest, error)
	grpc.ServerStream
}

type synchronizerSynchronizeServer struct {
	grpc.ServerStream
}

func (x *synchronizerSynchronizeServer) Send(m *SynchronizeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *synchronizerSynchronizeServer) Recv() (*SynchronizeRequest, error) {
	m := new(SynchronizeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Synchronizer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openmatch.internal.Synchronizer",
	HandlerType: (*SynchronizerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Synchronize",
			Handler:       _Synchronizer_Synchronize_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "internal/api/synchronizer.proto",
}
